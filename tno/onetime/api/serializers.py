# -*- coding: utf-8 -*-
from __future__ import print_function, unicode_literals
from base64 import b64decode, b64encode

from rest_framework import serializers

from ..models import OTSecret
from ..utils import len_base64


class Base64Field(serializers.RegexField):
    """
    Serializer field for validating base64-encoded strings.
    Also accepts a custom ``length`` parameter which can be
    used to validate how many bytes the field should accept.
    """

    def __init__(self, *args, **kwargs):
        self.decode = kwargs.pop('decode', False)

        length = kwargs.pop('length', None)
        if length:
            kwargs['min_length'] \
                = kwargs['max_length'] \
                = len_base64(length)

        kwargs['regex'] = (
            r'^(?:[A-Za-z0-9+/]{4})*'
            r'(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$'
        )

        super(Base64Field, self).__init__(*args, **kwargs)

    def to_native(self, value):
        """
        Encode the value as base64 if required
        """
        if value and self.decode:
            value = b64encode(value)
        return super(Base64Field, self).to_native(value)

    def field_from_native(self, data, files, field_name, into):
        """
        User ``field_from_native`` instead of ``from_native``
        because it allows to run validators before
        data is normalized hence it can be checked that
        submitted data is indeed base64 by the submitted
        length and regex.
        """
        super(Base64Field, self).field_from_native(data, files, field_name, into)
        value = into.get(self.source or field_name)
        if value and self.decode:
            value = b64decode(value)
            into[self.source or field_name] = value


class OTSecretSerializer(serializers.ModelSerializer):
    """
    One-Time-Secret serializer
    """
    uuid = serializers.CharField(
        read_only=True,
        help_text='UUID used in URL to retrieve previously created '
                  'secrete message.'
    )
    salt = Base64Field(
        length=32,
        decode=True,
        help_text='Final salt for the secret message password '
                  '(not sent to the server at any time) which '
                  'for better security should be generated from '
                  'both client and server\'s entropy sources. '
                  'Should be 32 bytes (256 bits) and must be submitted '
                  'as base64 encoded string.',
    )
    iv = Base64Field(
        length=32,
        decode=True,
        help_text='Final IV (initialization vector) for the AES256-GCM '
                  'cipher to encrypt user secret message which '
                  'for better security should be generated from '
                  'both client and server\'s entropy sources. '
                  'Should be 32 bytes (256 bits) and must be submitted '
                  'as base64 encoded string.',
    )
    associated_data = Base64Field(
        length=16,
        decode=True,
        help_text='Final associated data for the AES256-GCM '
                  'which is used by GCM to generate authentication '
                  'tag which is used during decyption to verify '
                  'validity of the supplied password. '
                  'For better security should be generated from '
                  'both client and server\'s entropy sources. '
                  'Should be 16 bytes (128 bits) and must be submitted '
                  'as base64 encoded string.',
    )
    tag = Base64Field(
        length=16,
        decode=True,
        help_text='Message authentication tag as generated by GCM '
                  'during encryption. '
                  'Should be 16 bytes (128 bits) and must be submitted '
                  'as base64 encoded string.',
    )
    ciphertext = Base64Field(
        decode=False,
        help_text='Ciphertext client generated by encrypting user '
                  'secret message via AES256-GCM by using the following '
                  'terms where s is server prefix and c client prefix: '
                  'SALT = sSALT⊕cSALT; '
                  'IV = sIV⊕cIV; '
                  'ADATA = sADATA⊕cADATA; '
                  'KEY = PBKDF2(PASS, SALT, 30000, SHA256);'
                  '--- ciphertext, tag = AES256-GCM(message, KEY, IV, ADATA). '
                  'Can be of any length and must be be submitted as base64 '
                  'encoded string.',
    )

    class Meta(object):
        model = OTSecret
        exclude = (
            'id',
            'user',
        )
        read_only_fields = (
            'created',
            'expires',
        )

    def save_object(self, obj, **kwargs):
        return super(OTSecretSerializer, self).save_object(obj, **kwargs)
